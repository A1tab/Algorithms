# Наибольшая общая подпоследовательность 2 списков. Подпоследовательность содержит элементы в исходном порядке, но, вероятно не все

def gcs(a,b):
    f = [[0] * (len(b)+1) for i in range(len(a)+1)]
    for i in range(1, len(a)+1):
        #print(f)
        for j in range(1, len(b)+1):
            #print(f'Сравниваем a[{i-1}]={a[i-1]} и b[{j-1}]={b[j-1]}')
            if a[i-1] == b[j-1]:
                #print(f'Они равны, {f[i][j]} = 1 + {f[i-1][j-1]}')
                f[i][j] = 1 + f[i-1][j-1]
            else:
                #print(f'Они НЕ равны, {f[i][j]} = max от {f[i-1][j]} и {f[i][j-1]}')
                f[i][j] = max(f[i-1][j], f[i][j-1])
    print(f)

    max_sec = ''
    i = len(a)                              # Чтобы найти ноп нужно переместиться в самый конец матрицы и идти в начало 
    j = len(b)                             
    while f[i][j] > 0:                      # Когда левый и правый элемент матрицы ответов f равен текущему, мы идем "по ним", т.е. вверх или вниз
        if f[i][j] == f[i][j-1]:            
            j -= 1                          
        elif f[i][j] == f[i-1][j]:
            i -= 1
        else:                                   # Когда они оба не равны, значит тут был общий элемент наибольшей подпоследовательности =>
            max_sec = str(a[i-1]) + max_sec     # => добавляем его в max_sec и переходим по диагонали (в матрице) т.е. i-=1 и j-=1
            i -= 1
            j -= 1
    print('Длина наибольшей общей последовательности: ', f[-1][-1])        
    print('Сама последовательность: ', max_sec)
    return f[-1][-1], max_sec


q = [5,1,2,3,4,5]
w = [5,2,3,4,1,5]
q2 = [1,2,3,4,5]
t = [8,8,8,9,9,9,1,2,3,7,7,7,7]
e = [1,2,3,4,5,5,1,8,8,8,9,9,9]
r = [1,2,3,1,5,5,6,8,8,8,9,9,9]
y = 'baccbca'
u = 'abcabaac'

print(gcs(y,u))
