# Задача про кузнечика. Кузнечик стоит в точке 1 и может прыгать на +1, +2 и +3. Нужно посчитать сколькими разными траекториями он
# может добраться до точки n, минуя случайно выбранные мертвые точки

import random

def gen_dead_points(n, number_of_dp=3):         # Если выпадет 3 точки подряд, то кузнечик не достигнет цели, но кому щас легко
    mas = [True] * (n+1)
    for i in range(number_of_dp):
        mas[random.randint(2,n-1)] = False      # Иногда он дважды попадает в одну и ту же точку, и тогда будет меньше dp
    print(mas)
    return mas

def grasshopper_traj(n):
    allow = gen_dead_points(n)
    fib = [0,1, int(allow[2])] + [0] * (n-2)            # fib это список в который заносятся ответы для каждой точки
    for i in range(3,n+1):
        if allow[i]:
            fib[i] = fib[i-1] + fib[i-2] + fib[i-3]
    print(fib)
    return fib[n]

print(grasshopper_traj(10))


# Задача про ладью. Нужно найти сколькими разными маршрутами ладья может добраться в клетку kj, при условии что она ходит по 1 клетке
# Размер поля MN
# M - строки
# N - столбцы
def rook_traj(k,j, M=10, N=10):                        
    dm = [[0]*M for i in range(N)]                  # Создаем поле (двумерный массив) и заполняем 0
    dm[0][1] = 1                                    # 0-строка и 0-столбец не используются, они остаются 0ми и нужны чтобы не выйти за границы
    for i in range(1,M):                            # но в [0][1] поместим 1, чтобы от нее начать заполнение 
        for g in range(1,N):
            dm[i][g] = dm[i-1][g] + dm[i][g-1]
    return(dm[k][j])


print(rook_traj(6,6))