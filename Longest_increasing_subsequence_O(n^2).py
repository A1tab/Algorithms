# Наибольшая возрастающая подпоследовательность от последовательности а. Она содержит элементы в исходном порядке, идущие по возрастанию
# Сложность обеих реализаций О(n^2)

# 2, 7, 1, 4, 3, 5, 4, 6, 2, 5, 8, 3
def gis(a):                                     # В этой реализации восстановление нвп осуществляется с помощью предков
    n = len(a)
    F = [0] * n
    prev = [-1] * n                             # Список предков, -1 значит что у элемента предков нет, иначе там будет индекс предка
    for i in range(n):
        # Чему равно F[i]?
        # F[i] = max(F[j], j < i, a[j] < a[i]) + 1
        m = 0
        for j in range(i):
            if a[j] < a[i] and F[j] > m:        # Вот так он берет первый элемент a[i] который удовлетворил условиям, а если поставить 
                m = F[j]                        # F[j] >= m то будет брать последний, и тогда мы получим другие нвп 
                prev[i] = j
        F[i] = m + 1

    ans = []                                # ans будет содержать нвп
    i = F.index(max(F))                     # Мы должны встать в позицию где длина нвп максимальная (это max(F)), для этого узнаем ее 
    ans.append(a[i])                        # индекс методом .index(), и элемент списка а с этим индексом и будет первым членом нвп
    while prev[i] != -1:                    # т.е. пока у текущего элемента есть предок
        i = prev[i]                         # идем к прошлому предку и добавляем его в нвп
        ans.append(a[i])                    
    ans = ans[::-1]                         # ответ с нвп нужно перевернуть, т.к. мы добавляли элементы в обратном порядке

    print('Длина нвп: ', max(F))
    print('Сама нвп: ', ans)
    return ans


gis([2, 7, 2, 4, 3, 5, 4, 6, 2, 5, 8, 3])


def gis_2(a):                                   # В этой реализации восстановление нвп осуществляется обратным ходом
    n = len(a)
    F = [0] * n
    for i in range(n):
        # Чему равно F[i]?
        # F[i] = max(F[j], j < i, a[j] < a[i]) + 1
        m = 0
        for j in range(i):
            if a[j] < a[i] and F[j] > m:        # Вот так он берет первый элемент a[i] который удовлетворил условиям, а если поставить 
                m = F[j]                        # F[j] >= m то будет брать последний, и тогда мы получим другие нвп 
        F[i] = m + 1

    ans = []                                # ans будет содержать нвп
    i = F.index(max(F))                     # Мы должны встать в позицию где длина нвп максимальная (это max(F)), для этого узнаем ее 
    ans.append(a[i])                        # индекс методом .index(), и элемент списка а с этим индексом и будет первым членом нвп
    while F[i] > 1:                         # Проверяем имеет ли этот элемент нвп длиной больше 1 (1 это он сам)
        # Ищем a[j] которое: a[j] < a[i] and F[j] == F[i] - 1
        j = i - 1
        while not(a[j] < a[i]) or not(F[j] == F[i] - 1):        # Пока "не нашли" т.е. пока одно из условий выше не выполнено - 
            j -= 1                                              # - либо нет потенциального элемента на прошлую позицию,
        ans.append(a[j])                                        # либо его F[i] не подходит
        i = j
    ans = ans[::-1]                             # ответ с нвп нужно перевернуть, т.к. мы добавляли элементы в обратном порядке

    print('Длина нвп: ', max(F))
    print('Сама нвп: ', ans)
    return ans


gis_2([2, 7, 2, 4, 3, 5, 4, 6, 2, 5, 8, 3])